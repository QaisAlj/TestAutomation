name: Automated Vulnerability Scan

on:
  push:
  pull_request:

jobs:
  scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for diff
    
    - name: Detect changed files
      id: changed-files
      uses: tj-actions/changed-files@v40
      with:
        files: |
          **/package.json
          **/requirements.txt
          **/pom.xml
          **/*.py
          **/*.java
          **/*.cpp
          **/*.c
    
    - name: Check for dependency files
      id: check-deps
      run: |
        if [ -n "${{ steps.changed-files.outputs.any_changed }}" ]; then
          DEPS_FOUND=false
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ "$file" == *"package.json" ]] || [[ "$file" == *"requirements.txt" ]] || [[ "$file" == *"pom.xml" ]]; then
              DEPS_FOUND=true
              break
            fi
          done
          echo "deps_found=$DEPS_FOUND" >> $GITHUB_OUTPUT
        else
          echo "deps_found=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Check for source code files
      id: check-source
      run: |
        if [ -n "${{ steps.changed-files.outputs.any_changed }}" ]; then
          SOURCE_FOUND=false
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ "$file" == *.py ]] || [[ "$file" == *.java ]] || [[ "$file" == *.cpp ]] || [[ "$file" == *.c ]]; then
              SOURCE_FOUND=true
              break
            fi
          done
          echo "source_found=$SOURCE_FOUND" >> $GITHUB_OUTPUT
        else
          echo "source_found=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Install Python dependencies
      if: steps.check-deps.outputs.deps_found == 'true' || steps.check-source.outputs.source_found == 'true'
      run: |
        pip install requests --quiet
    
    - name: Scan dependencies
      if: steps.check-deps.outputs.deps_found == 'true'
      id: scan-deps
      run: |
        # Collect dependency files and create JSON
        python3 << 'EOF'
        import json
        import os
        import sys
        
        # Get changed files from environment (space-separated)
        changed_files_str = os.environ.get('CHANGED_FILES', '')
        changed_files = changed_files_str.split() if changed_files_str else []
        
        files_data = []
        
        for file_path in changed_files:
            if any(file_path.endswith(ext) for ext in ['package.json', 'requirements.txt', 'pom.xml']):
                if os.path.isfile(file_path):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                        files_data.append({
                            "path": file_path,
                            "content": content
                        })
                    except Exception as e:
                        print(f"Warning: Could not read {file_path}: {e}", file=sys.stderr)
        
        if not files_data:
            print("No dependency files found to scan", file=sys.stderr)
            sys.exit(0)
        
        # Handle PR number - only set if it's a pull request event
        pr_number = None
        pr_number_str = os.environ.get('PR_NUMBER', '')
        if pr_number_str and pr_number_str.strip() and pr_number_str.strip() != 'null':
            try:
                pr_number = int(pr_number_str)
            except ValueError:
                pr_number = None
        
        payload = {
            "files": files_data,
            "repository": os.environ.get('GITHUB_REPOSITORY'),
            "commit_sha": os.environ.get('GITHUB_SHA'),
            "pr_number": pr_number,
            "event_type": os.environ.get('GITHUB_EVENT_NAME', 'push')
        }
        
        import requests
        api_url = os.environ.get('SCANNER_API_URL')
        api_token = os.environ.get('SCANNER_API_TOKEN', '')
        
        if not api_url:
            print("Error: SCANNER_API_URL secret is not set", file=sys.stderr)
            sys.exit(1)
        
        # Strip trailing slash from API URL to avoid double slashes
        api_url = api_url.rstrip('/')
        
        headers = {"Content-Type": "application/json"}
        if api_token:
            headers["Authorization"] = f"Bearer {api_token}"
        
        # Verify API is accessible with health check
        try:
            health_response = requests.get(f"{api_url}/health", timeout=10)
            health_response.raise_for_status()
            print(f"‚úÖ API health check passed: {health_response.json()}", file=sys.stderr)
        except Exception as e:
            print(f"‚ö†Ô∏è  API health check failed: {e}", file=sys.stderr)
            print(f"   API URL: {api_url}", file=sys.stderr)
            print(f"   This might indicate the API is not deployed or URL is incorrect", file=sys.stderr)
        
        # Debug: Print the URL being called
        endpoint_url = f"{api_url}/github/scan-dependencies"
        print(f"Calling API endpoint: {endpoint_url}", file=sys.stderr)
        
        try:
            response = requests.post(
                endpoint_url,
                json=payload,
                headers=headers,
                timeout=600
            )
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2))
            # Save result to file for summary
            with open('/tmp/deps_scan_result.json', 'w') as f:
                json.dump(result, f, indent=2)
        except requests.exceptions.RequestException as e:
            print(f"Error calling scanner API: {e}", file=sys.stderr)
            if hasattr(e, 'response') and e.response is not None:
                print(f"Response: {e.response.text}", file=sys.stderr)
            sys.exit(1)
        EOF
      env:
        CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        SCANNER_API_URL: ${{ secrets.SCANNER_API_URL }}
        SCANNER_API_TOKEN: ${{ secrets.SCANNER_API_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
    
    - name: Scan source code with ML
      if: steps.check-source.outputs.source_found == 'true'
      id: scan-ml
      run: |
        # Collect source code files and create JSON
        python3 << 'EOF'
        import json
        import os
        import sys
        
        # Get changed files from environment (space-separated)
        changed_files_str = os.environ.get('CHANGED_FILES', '')
        changed_files = changed_files_str.split() if changed_files_str else []
        
        files_data = []
        
        for file_path in changed_files:
            if any(file_path.endswith(ext) for ext in ['.py', '.java', '.cpp', '.c']):
                if os.path.isfile(file_path):
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        # Determine language
                        if file_path.endswith('.py'):
                            language = 'Python'
                        elif file_path.endswith('.java'):
                            language = 'Java'
                        elif file_path.endswith('.cpp') or file_path.endswith('.c'):
                            language = 'C/C++'
                        else:
                            language = 'Unknown'
                        
                        # Count lines
                        lines = len(content.splitlines())
                        
                        files_data.append({
                            "path": file_path,
                            "filename": os.path.basename(file_path),
                            "language": language,
                            "content": content,
                            "lines_of_code": lines
                        })
                    except Exception as e:
                        print(f"Warning: Could not read {file_path}: {e}", file=sys.stderr)
        
        if not files_data:
            print("No source code files found to scan", file=sys.stderr)
            sys.exit(0)
        
        # Handle PR number - only set if it's a pull request event
        pr_number = None
        pr_number_str = os.environ.get('PR_NUMBER', '')
        if pr_number_str and pr_number_str.strip() and pr_number_str.strip() != 'null':
            try:
                pr_number = int(pr_number_str)
            except ValueError:
                pr_number = None
        
        payload = {
            "files": files_data,
            "repository": os.environ.get('GITHUB_REPOSITORY'),
            "commit_sha": os.environ.get('GITHUB_SHA'),
            "pr_number": pr_number,
            "event_type": os.environ.get('GITHUB_EVENT_NAME', 'push')
        }
        
        import requests
        api_url = os.environ.get('SCANNER_API_URL')
        api_token = os.environ.get('SCANNER_API_TOKEN', '')
        
        if not api_url:
            print("Error: SCANNER_API_URL secret is not set", file=sys.stderr)
            sys.exit(1)
        
        # Strip trailing slash from API URL to avoid double slashes
        api_url = api_url.rstrip('/')
        
        headers = {"Content-Type": "application/json"}
        if api_token:
            headers["Authorization"] = f"Bearer {api_token}"
        
        # Verify API is accessible with health check
        try:
            health_response = requests.get(f"{api_url}/health", timeout=10)
            health_response.raise_for_status()
            print(f"‚úÖ API health check passed: {health_response.json()}", file=sys.stderr)
        except Exception as e:
            print(f"‚ö†Ô∏è  API health check failed: {e}", file=sys.stderr)
            print(f"   API URL: {api_url}", file=sys.stderr)
            print(f"   This might indicate the API is not deployed or URL is incorrect", file=sys.stderr)
        
        # Debug: Print the URL being called
        endpoint_url = f"{api_url}/github/scan-ml"
        print(f"Calling API endpoint: {endpoint_url}", file=sys.stderr)
        
        try:
            response = requests.post(
                endpoint_url,
                json=payload,
                headers=headers,
                timeout=600
            )
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2))
            # Save result to file for summary
            with open('/tmp/ml_scan_result.json', 'w') as f:
                json.dump(result, f, indent=2)
        except requests.exceptions.RequestException as e:
            print(f"Error calling ML scanner API: {e}", file=sys.stderr)
            if hasattr(e, 'response') and e.response is not None:
                print(f"Response: {e.response.text}", file=sys.stderr)
            sys.exit(1)
        EOF
      env:
        CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        SCANNER_API_URL: ${{ secrets.SCANNER_API_URL }}
        SCANNER_API_TOKEN: ${{ secrets.SCANNER_API_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
    
    - name: Display Scan Summary
      if: always() && (steps.check-deps.outputs.deps_found == 'true' || steps.check-source.outputs.source_found == 'true')
      run: |
        python3 << 'EOF'
        import json
        import os
        import sys
        
        summary_lines = []
        summary_lines.append("# üîç Vulnerability Scan Summary")
        summary_lines.append("")
        summary_lines.append(f"**Repository:** {os.environ.get('GITHUB_REPOSITORY', 'N/A')}")
        summary_lines.append(f"**Branch:** {os.environ.get('GITHUB_REF_NAME', 'N/A')}")
        summary_lines.append(f"**Commit:** {os.environ.get('GITHUB_SHA', 'N/A')[:7]}")
        summary_lines.append(f"**Event:** {os.environ.get('GITHUB_EVENT_NAME', 'N/A')}")
        summary_lines.append("")
        summary_lines.append("---")
        summary_lines.append("")
        
        # Dependency Scan Results
        deps_scan_file = '/tmp/deps_scan_result.json'
        if os.path.exists(deps_scan_file):
            summary_lines.append("## üì¶ Dependency Scan Results")
            summary_lines.append("")
            try:
                with open(deps_scan_file, 'r') as f:
                    deps_result = json.load(f)
                
                if isinstance(deps_result, dict):
                    # Get summary stats
                    summary = deps_result.get('summary', {})
                    total_vulns = summary.get('total_vulnerabilities', 0)
                    vuln_by_severity = summary.get('vulnerabilities_by_severity', {})
                    
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append(f"**Dependencies Scanned:** {summary.get('total_deps_scanned', 0)}")
                    summary_lines.append(f"**Dependencies with Vulnerabilities:** {summary.get('deps_with_vulnerabilities', 0)}")
                    summary_lines.append(f"**Total Vulnerabilities:** {total_vulns}")
                    summary_lines.append("")
                    
                    if total_vulns > 0:
                        # Show severity breakdown
                        if vuln_by_severity:
                            summary_lines.append("**Severity Breakdown:**")
                            if vuln_by_severity.get('critical', 0) > 0:
                                summary_lines.append(f"- üî¥ Critical: {vuln_by_severity['critical']}")
                            if vuln_by_severity.get('high', 0) > 0:
                                summary_lines.append(f"- üü† High: {vuln_by_severity['high']}")
                            if vuln_by_severity.get('medium', 0) > 0:
                                summary_lines.append(f"- üü° Medium: {vuln_by_severity['medium']}")
                            if vuln_by_severity.get('low', 0) > 0:
                                summary_lines.append(f"- üü¢ Low: {vuln_by_severity['low']}")
                            summary_lines.append("")
                        
                        # List vulnerabilities from dependencies only (ignore duplicate root vulnerabilities array)
                        summary_lines.append("### Affected Dependencies:")
                        summary_lines.append("")
                        
                        dependencies = deps_result.get('dependencies', [])
                        vuln_count = 0
                        
                        # Severity ordering for sorting (highest to lowest)
                        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'UNKNOWN': 4}
                        
                        def get_severity_rank(cve):
                            """Get severity rank for sorting (lower number = higher severity)"""
                            severity = cve.get('severity', 'Unknown').upper()
                            return severity_order.get(severity, 4)
                        
                        for dep in dependencies:
                            if isinstance(dep, dict):
                                cves = dep.get('cves', [])
                                if cves:
                                    pkg_name = dep.get('name', 'Unknown')
                                    pkg_version = dep.get('version', 'Unknown')
                                    summary_lines.append(f"#### {pkg_name} ({pkg_version})")
                                    
                                    # Sort CVEs by severity (highest to lowest)
                                    sorted_cves = sorted(cves, key=get_severity_rank)
                                    
                                    for cve in sorted_cves[:5]:  # Show first 5 CVEs per package (sorted by severity)
                                        vuln_count += 1
                                        if vuln_count > 15:  # Stop after 15 total
                                            break
                                        
                                        cve_id = cve.get('cve_id', 'N/A')
                                        severity = cve.get('severity', 'Unknown').upper()
                                        cvss = cve.get('cvss_score', 'N/A')
                                        cwe = cve.get('cwe', 'N/A')
                                        cisa_kev = cve.get('cisa_kev', 'No')
                                        url = cve.get('url', '')
                                        
                                        severity_emoji = {
                                            'CRITICAL': 'üî¥',
                                            'HIGH': 'üü†',
                                            'MEDIUM': 'üü°',
                                            'LOW': 'üü¢'
                                        }.get(severity, '‚ö™')
                                        
                                        # CISA KEV badge
                                        kev_badge = ' ‚ö†Ô∏è **CISA KEV**' if cisa_kev == 'Yes' else ''
                                        
                                        # Build CVE line with link
                                        cve_link = f"[{cve_id}]({url})" if url else cve_id
                                        summary_lines.append(f"- {severity_emoji} **{cve_link}**{kev_badge}")
                                        summary_lines.append(f"  - **Severity:** {severity} | **CVSS:** {cvss}")
                                        summary_lines.append(f"  - **CWE:** {cwe}")
                                    
                                    if len(sorted_cves) > 5:
                                        summary_lines.append(f"  *... and {len(sorted_cves) - 5} more CVEs*")
                                    summary_lines.append("")
                            
                            if vuln_count > 15:
                                remaining = total_vulns - vuln_count
                                if remaining > 0:
                                    summary_lines.append(f"*... and {remaining} more vulnerabilities. See full results below.*")
                                break
                    else:
                        summary_lines.append("‚úÖ No vulnerabilities detected in dependencies!")
                    
                    # Show full JSON in collapsible section
                    summary_lines.append("")
                    summary_lines.append("<details>")
                    summary_lines.append("<summary>View Full Dependency Scan Results</summary>")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(deps_result, indent=2))
                    summary_lines.append("```")
                    summary_lines.append("</details>")
                else:
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(deps_result, indent=2))
                    summary_lines.append("```")
            except Exception as e:
                summary_lines.append(f"**Status:** ‚ö†Ô∏è Error reading results")
                summary_lines.append(f"**Error:** {str(e)}")
        else:
            summary_lines.append("## üì¶ Dependency Scan Results")
            summary_lines.append("")
            summary_lines.append("‚ÑπÔ∏è No dependency files were scanned")
        
        summary_lines.append("")
        summary_lines.append("---")
        summary_lines.append("")
        
        # ML Source Code Scan Results
        ml_scan_file = '/tmp/ml_scan_result.json'
        if os.path.exists(ml_scan_file):
            summary_lines.append("## ü§ñ ML Source Code Scan Results")
            summary_lines.append("")
            try:
                with open(ml_scan_file, 'r') as f:
                    ml_result = json.load(f)
                
                if isinstance(ml_result, dict):
                    # Extract key information from predictions array
                    predictions = ml_result.get('predictions', [])
                    summary = ml_result.get('summary', {})
                    
                    # Filter for vulnerable files only
                    vulnerable_predictions = [
                        p for p in predictions 
                        if isinstance(p, dict) and p.get('success') and p.get('prediction') == 'VULNERABLE'
                    ]
                    
                    total_files = summary.get('total_files', 0)
                    vulnerable_files = summary.get('vulnerable_files', len(vulnerable_predictions))
                    safe_files = summary.get('safe_files', 0)
                    failed_files = summary.get('failed_files', 0)
                    analysis_time = summary.get('analysis_time_seconds', 0)
                    
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append(f"**Total Files Analyzed:** {total_files}")
                    summary_lines.append(f"**Vulnerable Files:** {vulnerable_files}")
                    summary_lines.append(f"**Safe Files:** {safe_files}")
                    if failed_files > 0:
                        summary_lines.append(f"**Failed Files:** {failed_files}")
                    summary_lines.append(f"**Analysis Time:** {analysis_time}s")
                    summary_lines.append("")
                    
                    if vulnerable_files > 0:
                        summary_lines.append("### ‚ö†Ô∏è Vulnerable Files Detected:")
                        summary_lines.append("")
                        for i, pred in enumerate(vulnerable_predictions[:10], 1):  # Show first 10
                            file_path = pred.get('file_path', pred.get('filename', 'Unknown'))
                            filename = pred.get('filename', 'Unknown')
                            risk_level = pred.get('risk_level', 'Unknown')
                            confidence = pred.get('confidence', 0)
                            confidence_pct = int(confidence * 100) if confidence else 0
                            language = pred.get('language', 'Unknown')
                            
                            risk_emoji = {
                                'CRITICAL': 'üî¥',
                                'HIGH': 'üü†',
                                'MEDIUM': 'üü°',
                                'LOW': 'üü¢'
                            }.get(risk_level, '‚ö™')
                            
                            summary_lines.append(f"{i}. {risk_emoji} **{file_path}**")
                            summary_lines.append(f"   - **Risk Level:** {risk_level} | **Confidence:** {confidence_pct}% | **Language:** {language}")
                        
                        if vulnerable_files > 10:
                            summary_lines.append(f"\n*... and {vulnerable_files - 10} more vulnerable files*")
                    else:
                        summary_lines.append("‚úÖ No security issues detected in source code!")
                    
                    # Show full JSON in collapsible section
                    summary_lines.append("")
                    summary_lines.append("<details>")
                    summary_lines.append("<summary>View Full ML Scan Results</summary>")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(ml_result, indent=2))
                    summary_lines.append("```")
                    summary_lines.append("</details>")
                else:
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(ml_result, indent=2))
                    summary_lines.append("```")
            except Exception as e:
                summary_lines.append(f"**Status:** ‚ö†Ô∏è Error reading results")
                summary_lines.append(f"**Error:** {str(e)}")
        else:
            summary_lines.append("## ü§ñ ML Source Code Scan Results")
            summary_lines.append("")
            summary_lines.append("‚ÑπÔ∏è No source code files were scanned")
        
        summary_lines.append("")
        summary_lines.append("---")
        summary_lines.append("")
        
        # Write summary to both stdout and file
        summary_text = "\n".join(summary_lines)
        print(summary_text)
        
        # Write to GitHub Actions summary
        summary_file = os.environ.get('GITHUB_STEP_SUMMARY', '/dev/null')
        try:
            with open(summary_file, 'w') as f:
                f.write(summary_text)
        except Exception:
            pass  # Ignore if file doesn't exist
        
        EOF
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_REF_NAME: ${{ github.ref_name }}
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}